# 前言
&nbsp;&nbsp;&nbsp;&nbsp;在之前我们已经完成了基于ucontext库封装协程类, 现在我们来完成协程调度器的实现
# 协程调度知识
&nbsp;&nbsp;&nbsp;&nbsp;在前⾯的协程模块中，对于每个协程，都需要⽤户⼿动调⽤协程的swapIn⽅法切换到该协程运⾏起来，然后等协程运⾏结束并返回，再运⾏下⼀个协程。这种运⾏协程的⽅式其实是⽤户⾃⼰在挑选协程执⾏，相当于⽤户在充当调度器，显然不够灵活。引⼊协程调度后，则可以先创建⼀个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程⼀个⼀个消耗掉
## 一个简单的调度器
&nbsp;&nbsp;&nbsp;&nbsp;我们很容易就能想到一个先入先出调度的简单调度器
``` cpp
class Scheduler 
{
public:
//插入一个协程即可
void schedule(sylar::Fiber::ptr task);
//遍历任务队列一个个执行即可
void run() ;
private:
    std::list<Fiber::ptr> _tasks;
};
```
当然肯定不能这样实现
## 协程调度需求
1. 对于一个协程调度器, 当然是要调度协程的, 但实际上函数也应该可以进行调度,

